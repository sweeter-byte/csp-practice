# T3 图片解码 - 解题思路与算法设计

## 1. 问题分析

本题要求还原经过多次加密操作（旋转和翻转）后的原始图片。
已知信息包括：
*   最终加密后的图片 $A_t$ ($Z \times Z$)。
*   操作序列 $K$（包含每次操作的类型及参数）。
*   加密过程是从 $A_0$ 逐步演变到 $A_t$。

由于加密操作是确定性的且每一步都保留了完整信息，理论上可以通过**逆向操作**从 $A_t$ 逐步还原回 $A_0$。

## 2. 核心难点与优化策略

### 难点：时间复杂度
题目中 $Z \le 400$，操作次数 $t \le 5 \times 10^4$。
如果每次操作都对整个 $Z \times Z$ 的矩阵进行真实的内存搬运（尤其是全局旋转），单次操作复杂度为 $O(Z^2)$。
总复杂度为 $O(t \cdot Z^2) \approx 5 \times 10^4 \times 16 \times 10^4 = 8 \times 10^9$，远超通常的 $10^8$ 指令限制（1.5秒时限），会导致**超时 (TLE)**。

### 策略一：逆向模拟 (Reverse Simulation)
加密是从 $A_0 \to A_t$，解密则是 $A_t \to A_0$。
我们需要**倒序遍历**操作步骤，并执行每一步操作的**逆操作**：
*   **旋转加密的逆操作**：将子图反向旋转（顺时针 $d$ 度 $\to$ 逆时针 $d$ 度）。
*   **翻转加密的逆操作**：再次执行相同的翻转（翻转是自反的，即 $Flip(Flip(X)) = X$）。

### 策略二：坐标映射 (Coordinate Mapping)
为了解决超时问题，必须观察到题目中操作的特殊性：
1.  **全局操作**：仅涉及整张图的旋转。
2.  **局部操作**：仅涉及很小的子矩形（$L \le 10$ 或边长 $\le 10$）。

如果我们将“全局旋转”和“局部修改”解耦：
*   **不要物理旋转整个网格**。
*   维护一个全局的**视角状态 (View Rotation)**。
    *   当需要全局旋转时，只修改这个状态变量（$O(1)$）。
    *   当需要读写某个网格点 $(r, c)$ 时，根据当前的“视角状态”，计算其在物理内存中实际对应的坐标 $(rr, cc)$。
*   对于局部操作，由于涉及的区域极小（最多 $10 \times 10$），直接进行物理读写和计算，复杂度 $O(L^2)$ 是可以忽略的。

通过这种**虚拟旋转**技术，我们将单次操作的复杂度从 $O(Z^2)$ 降低到了 $O(L^2)$（其中 $L \le 10$），总复杂度降约为 $O(t \cdot L^2)$，可以轻松通过。

## 3. 算法设计

### 3.1 数据结构
*   `grid[MAXZ][MAXZ]`: 存储当前的字符矩阵。
*   `current_rotation`: 整数 $0 \sim 3$，表示当前逻辑视角相对于物理存储顺时针旋转了多少个 $90^\circ$。

### 3.2 坐标映射函数 `map_coord(r, c)`
输入逻辑坐标 $(r, c)$，根据 `current_rotation` 返回物理坐标 $(rr, cc)$。
*   若 `current_rotation == 0`: $(r, c) \to (r, c)$
*   若 `current_rotation == 1` (90° CW): $(r, c) \to (Z-1-c, r)$
*   若 `current_rotation == 2` (180° CW): $(r, c) \to (Z-1-c, r) \to (Z-1-r, Z-1-c)$
*   若 `current_rotation == 3` (270° CW): $(r, c) \to \dots \to (c, Z-1-r)$

### 3.3 逆向操作流程
1.  **读取输入**：读取 $Z$ 和最终图矩阵 $A_t$ 存入 `grid`。
2.  **解析密钥**：读取 $K$，还原出 $t$ 个操作的所有参数，存入 `steps` 数组。
3.  **倒序执行** ($i = t-1 \to 0$)：
    *   如果是 **Op 1 (旋转加密)**:
        *   **第一步：撤销全局旋转**。加密时整图逆时针旋转 $90^\circ \times r_i$，解密则需将视角顺时针调整相同角度。
            *   更新 `current_rotation = (current_rotation + r_i) % 4`。
        *   **第二步：撤销局部旋转**。
            *   根据当前 `current_rotation`，从 `grid` 中提取出逻辑坐标 $(u_i, v_i)$ 开始的 $L_i \times L_i$ 子块。
            *   将该子块进行**逆时针** $d_i$ 度旋转（还原之前的顺时针 $d_i$）。
            *   将处理后的子块写回 `grid`。
    *   如果是 **Op 2 (翻转加密)**:
        *   **撤销局部翻转**。
        *   提取逻辑坐标范围内的子矩形。
        *   执行相同的翻转操作（上下或左右）。
        *   写回 `grid`。

### 3.4 输出结果
*   遍历逻辑坐标 $(r, c)$ ($0 \sim Z-1$)。
*   通过 `map_coord(r, c)` 获取字符。
*   找出非 `?` 字符的最大行下标和最大列下标，确定原始尺寸 $n, m$。
*   输出裁剪后的 $n \times m$ 矩阵。

## 4. 复杂度分析

*   **空间复杂度**: $O(Z^2)$，用于存储 $400 \times 400$ 的字符矩阵。
*   **时间复杂度**: $O(t \times L_{max}^2)$。
    *   $t \le 5 \times 10^4$
    *   $L_{max} \le 10$
    *   计算量约为 $5 \times 10^4 \times 100 = 5 \times 10^6$ 次运算，远小于 $10^8$，即使在最坏情况下也非常安全。

## 5. C++ 实现细节 (test3.cpp)

代码已经实现在 `T3/test3.cpp` 中。
关键点：
*   `op == 1` 时参数为 `u, v, L, d, r`。
*   `op == 2` 时参数为 `u, d, l, r, o`。
*   注意题目中的坐标是 1-based，代码中转为 0-based。
*   全局“逆时针旋转”在逆向过程中等价于 View 的“顺时针旋转”。


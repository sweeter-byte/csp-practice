# CSP 40 T5 - 数据抢修 (Repair) 解题报告

## 题目分析

### 问题转化
题目要求将一个可重集划分为若干个子集，使得每个子集内部任意两个元素 $x, y$ 满足 $x \oplus y \ge W$。我们需要最小化这样的子集数量。

定义冲突关系：如果两个元素 $x, y$ 满足 $x \oplus y < W$，则它们不能在同一个子集中，即产生**冲突**。
我们可以构建一个**冲突图** $G=(V, E)$，其中 $V$ 是所有元素的集合，边 $(u, v) \in E$ 当且仅当 $u \oplus v < W$。
问题转化为：求将图 $G$ 的顶点划分为最少数量的独立集（Independent Set）。
这等价于求图 $G$ 的**色数**（Chromatic Number），记为 $\chi(G)$。

### 0/1 Trie 上的递归性质
考虑到异或运算的位操作特性，我们可以结合 Trie 树（字典树）来解决这个问题。
我们将所有元素插入 Trie 树。对于 Trie 树上的任意一个节点 $u$，我们考虑其子树中所有元素构成的子冲突图，并计算其色数 $ans(u)$。

假设当前节点 $u$ 对应二进制的第 $k$ 位（从高到低，$MAX\_BITS \to 0$）。$W$ 的第 $k$ 位为 $w_k$。
节点 $u$ 有左子节点 $L$（代表第 $k$ 位为 0）和右子节点 $R$（代表第 $k$ 位为 1）。

#### 情况 1：$w_k = 0$
如果 $W$ 的当前位是 0，那么对于任意 $x \in L, y \in R$：
$x$ 的第 $k$ 位是 0，$y$ 的第 $k$ 位是 1。
$x \oplus y$ 的第 $k$ 位是 1。
因此 $x \oplus y \ge 2^k > W \pmod{2^{k+1}}$（只考虑当前位及更低位，且假设高位已匹配）。
这意味着 $L$ 集合和 $R$ 集合之间的所有元素都没有冲突。
冲突图分裂为两个不相连的部分 $G_L$ 和 $G_R$。
由于我们要对整个图染色，且两部分互不干涉，我们可以复用颜色。
$$ans(u) = \max(ans(L), ans(R))$$

#### 情况 2：$w_k = 1$
如果 $W$ 的当前位是 1，我们需要更细致的分析。
1.  **内部冲突**：
    对于 $L$ 内部任意两个元素 $x_1, x_2$，$x_1 \oplus x_2$ 的第 $k$ 位是 $0$。而 $W$ 要求第 $k$ 位是 1，且高位已完全匹配（相同）。
    这意味着 $x_1 \oplus x_2 < W$ 在更高位起作用之前就已经成立（实际上是在当前位就“输”了，因为 $0 < 1$）。
    因此，$L$ 集合内部**任意**两个元素都冲突。$L$ 的冲突图是一个**完全图**（Clique）。
    同理，$R$ 的冲突图也是一个完全图。
    这意味着 $L$ 中的每个元素都需要一个独立的颜色，$R$ 中同理。
    
2.  **合并策略**：
    虽然 $L$ 内部两两冲突，$R$ 内部两两冲突，但 $L$ 中的元素 $x$ 可能与 $R$ 中的元素 $y$ **兼容**（不冲突）。
    如果 $x \in L, y \in R$ 兼容（即 $x \oplus y \ge W$），我们可以让它们共享同一种颜色。
    为了最小化总颜色数，我们需要尽可能多地将 $L$ 中的元素和 $R$ 中的元素配对成兼容对。
    
    总颜色数 = $|L| + |R| - \text{最大兼容匹配数}(L, R)$
    
    这就转化为了一个**二分图最大匹配**问题。二分图左部是 $L$ 中元素，右部是 $R$ 中元素。边 $(x, y)$ 存在当且仅当 $x \oplus y \ge W$。

### 二分图匹配的递归计算
要计算 $L$ 和 $R$ 之间的最大匹配，我们也使用递归。
定义 `match(u, v, dep)` 为求解 Trie 树上节点 $u$（来自 $L$ 集合）和节点 $v$（来自 $R$ 集合）之间，考虑第 $dep$ 位及以下位的最大匹配数。

假设当前位是 $k$，$W$ 的第 $k$ 位为 $w_k$。

#### 1. 当 $w_k = 1$ 时
我们要寻找兼容对 $(x, y)$，必须满足 $x \oplus y$ 第 $k$ 位为 1（因为 $W$ 要求至少为 1）。
$u$ 的子节点 $u_L$ (0), $u_R$ (1)。
$v$ 的子节点 $v_L$ (0), $v_R$ (1)。
- $u_L \oplus v_L \to 0 < 1$ (冲突)
- $u_R \oplus v_R \to 0 < 1$ (冲突)
- $u_L \oplus v_R \to 1$ (可能兼容)
- $u_R \oplus v_L \to 1$ (可能兼容)

所以我们只能在 $(u_L, v_R)$ 之间和 $(u_R, v_L)$ 之间分别进行匹配。
$$match(u, v) = match(u_L, v_R) + match(u_R, v_L)$$

#### 2. 当 $w_k = 0$ 时
此时 $W$ 当前位为 0。
- $u_L \oplus v_R \to 1 > 0$。这是一定满足 $\ge W$ 的（在这一位上赢了）。所有 $u_L$ 中的元素和 $v_R$ 中的元素都兼容。这相当于二分图中 $(u_L, v_R)$ 部分是**完全二分图**，容量无穷大。
- $u_R \oplus v_L \to 1 > 0$。同理，完全兼容。
- $u_L \oplus v_L \to 0$。这一位相同，是平局，需要递归检查更低位是否满足 $\ge W$。即匹配数受限于 `match(u_L, v_L)`。
- $u_R \oplus v_R \to 0$。同理，受限于 `match(u_R, v_R)`。

这是一个特殊的网络流模型：
- 源点 $S$ 连接 $u_L$ 和 $u_R$，容量分别为 $|u_L|, |u_R|$。
- 汇点 $T$ 连接 $v_L$ 和 $v_R$，容量分别为 $|v_L|, |v_R|$。
- $u_L \to v_L$ 有限制，流量上限 $A = match(u_L, v_L)$。
- $u_R \to v_R$ 有限制，流量上限 $B = match(u_R, v_R)$。
- $u_L \to v_R$ 和 $u_R \to v_L$ 无限制（容量无穷）。

利用最大流最小割定理，最小割可以是：
1. 切断 $S$：割量 $|u_L| + |u_R|$ (即 $|u|$)
2. 切断 $T$：割量 $|v_L| + |v_R|$ (即 $|v|$)
3. 切断中间有限边和交叉路径：
   - 割掉 $u_L \to v_L$ (代价 A) 和 $u_L \to v_R$ (无意义，因为无穷大，所以不能割)
   - 实际上我们需要切断使得 $S$ 到 $T$ 不通。
   - 这里的割是指：如果不走无穷边，我们可以割掉限制边。如果走无穷边，比如 $u_L \to v_R$，我们需要割掉 $u_L$ 的入边或者 $v_R$ 的出边。
   
   实际上公式为：
   $$match(u, v) = \min(|u|, |v|, |u_L| + |v_L| + match(u_R, v_R), |u_R| + |v_R| + match(u_L, v_L))$$
   
   这个公式的推导逻辑是：
   - 总流量不能超过源总量 $|u|$。
   - 总流量不能超过汇总量 $|v|$。
   - 考虑 $u_L$：它可以流向 $v_L$ （最多 $A$）或者 $v_R$（无限）。但 $v_R$ 还要接收 $u_R$ 的流。
   - 正确的 Min-Cut 理解：
     - Cut 1: 割掉 $S \to u_L, S \to u_R$ (全割)。 Value: $|u|$.
     - Cut 2: 割掉 $v_L \to T, v_R \to T$ (全割)。 Value: $|v|$.
     - Cut 3: 割掉 $S \to u_L$ 和 $v_R \to T$ (阻止交叉流 $u_L \to v_R$)，同时利用 $u_R \to v_R$ 的最大通过量 $B$。即 $u_R$ 只能走 $B$ 到达 $T$。此时 $u_L$ 被阻断，$v_R$ 被阻断。总流量 = $B +$ (割掉的容量 $|u_L| + |v_R|$?) 不对。
     
     回溯到最大流逻辑：
     Flow = $\min($
       $|u|$,
       $|v|$,
       $|u_L| + |v_L| + match(u_R, v_R)$,  (让 $u_L$ 全流 $v_R$, $v_L$ 接收 $u_L$ 无望只能接 $A$ 但 $u_L$ 走了... 这种直观解释较乱)
       $|u_R| + |v_R| + match(u_L, v_L)$
     $)$
     
     **详细解释**：
     我们想最大化匹配。
     $u_L$ 可以匹配 $v_L$ (限额 $A$) 或 $v_R$ (无限制)。
     $u_R$ 可以匹配 $v_R$ (限额 $B$) 或 $v_L$ (无限制)。
     假设我们要填满 $u_L$，我们可以尽量用 $v_R$ 填，剩下的 $v_R$ 给 $u_R$ 用。
     这是一个有名的问题，公式即为上述四个值的最小值。

## 算法复杂度
- 每次插入/合并操作，本质上是在 Trie 上进行路径更新或合并。
- 只有当 $W$ 对应位为 0 时才会产生分支递归计算 $match$，这类似于 Trie 合并的复杂度。
- 总体复杂度接近 $O((N+Q) \log V)$ 或 $O((N+Q) \log^2 V)$，对于 $5 \times 10^5$ 的数据量是可以接受的。

## 代码实现要点
1.  **动态开点 Trie**：节省空间，只存存在的节点。
2.  **线段树合并 (Trie Merge)**：处理 `2 u v` 操作，将 $v$ 合并到 $u$。
3.  **垃圾回收 (Memory Pool)**：题目没要求强制在线删除，但合并后 $v$ 不再使用，可以直接复用或忽略。代码中未显式回收，因为总节点数在可控范围内。

## 这是最终提交的方案，已通过样例测试。

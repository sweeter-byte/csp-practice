# C形阵 (Problem 4) - 解题报告

## 1. 题目性质分析

题目给定的 数阵 $(A, B, C, D, E, F, G)$ 需要满足以下条件：
1.  **比例性质**：$\frac{A}{B} = \frac{B}{C}$ 且 $\frac{E}{F} = \frac{F}{G}$。这意味着 $A, B, C$ 成等比数列，$E, F, G$ 成等比数列。也就是 $AC = B^2$ 且 $EG = F^2$。
2.  **乘积性质**：$ABC = CDE = EFG$。

### 推导核心关系
由 $AC = B^2$ 可知 $ABC = B^3$。
由 $EG = F^2$ 可知 $EFG = F^3$。
结合 $ABC = EFG$，得到 $B^3 = F^3$，即 **$B = F$**。

再看中间的等式 $ABC = CDE$ (即 $B^3 = CDE$)：
代入 $C = B^2/A$ 和 $E = F^2/G = B^2/G$：
$$ B^3 = \frac{B^2}{A} \times D \times \frac{B^2}{G} $$
$$ B^3 = \frac{B^4 D}{AG} $$
$$ 1 = \frac{BD}{AG} \implies D = \frac{AG}{B} $$

### 结论
整个 C 形阵完全由 **$(A, B, G)$** 三个参数决定，其余元素可以表示为：
- $C = B^2 / A$
- $E = B^2 / G$
- $F = B$
- $D = AG / B$

为了保证所有元素为正整数，需满足整除条件：
1.  $A | B^2$ （保证 $C$ 是整数）
2.  $G | B^2$ （保证 $E$ 是整数）
3.  $B | AG$ （保证 $D$ 是整数）

## 2. 算法设计 (Op = 0)

对于 $Op=0$，我们需要求所有满足条件且大小 $B \le N$ 的 C 形阵的价值 $D$ 之和。
$$ \text{Total} = \sum_{B=1}^N \sum_{A|B^2} \sum_{G|B^2, B|AG} \frac{AG}{B} $$

令 $f(B) = \sum_{A|B^2} \sum_{G|B^2, B|AG} \frac{AG}{B}$。

### 积性函数性质
仔细观察 $f(B)$，可以证明它是**积性函数**（即若 $\gcd(x, y)=1$，则 $f(xy)=f(x)f(y)$）。
这就意味着我们可以使用 **线性筛 (Linear Sieve)** 在 $O(N)$ 时间内预处理出所有 $f(B)$ 的值。

### 质数幂处的计算 $f(p^k)$
对于 $B = p^k$，我们需要求所有 $0 \le a, g \le 2k$ 且 $a+g \ge k$ 的 pair $(p^a, p^g)$ 的贡献 $p^{a+g-k}$ 之和。
令 $s = a+g$，则 $s$ 的范围是 $[k, 4k]$。
对于固定的 $s$，有多少对 $(a, g)$ 满足 $a+g=s$ 且 $0 \le a, g \le 2k$？
- 若 $s \le 2k$，方案数为 $s+1$。
- 若 $s > 2k$，方案数为 $4k - s + 1$。
实际上，约束是 $\max(0, s-2k) \le a \le \min(s, 2k)$。

我们可以直接枚举 $s$ 来计算 $f(p^k)$。由于 $N=10^7$ 时 $k$ 很小（最大 23），直接循环计算非常快。

---

## 3. 算法设计 (Op = 1) - 完美 C 形阵

完美 C 形阵要求集合 $\{A, B, C, D, E, F, G\}$ 中恰有 6 个互不相同的元素。
已知 $F=B$，所以集合实际上是 $\{A, B, C, D, E, G\}$。
我们需要这 6 个数互不相同。

直接计算“互不相同”比较困难，我们可以使用 **容斥原理**（或者说是减法原理）：
$$ \text{Perfect Sum} = \text{Total Sum} - \text{Bad Sum} $$
**Bad Sum** 即存在重复元素的情况。

### 重复情况分析
我们需要分析哪些等式会导致元素重复：
1.  **$A=B$**：会导致 $C=B$，此时 $A=B=C$。贡献：$S_1(B) = \sum_{G|B^2} G$ (此时 $C=B \implies A=B$, $D=AG/B=G$)。注：需仔细推导价值。
2.  **$G=B$**：对称情况。
3.  **$A=G$**：会导致 $C=E$。
4.  **$AG=B^2$**：这等价于 $D=B$。
5.  **其他情况**：如 $A^2 G = B^3$ (等价于 $C=D$) 等。

经过详细推导（及脚本验证），坏情况的总贡献 $g(B)$ 可以表示为几个基础函数的线性组合：
$$ g(B) = 2 S_1(B) + S_3(B) + S_4(B) + 2 S_5(B) - 5 S_{12}(B) $$

其中：
- $S_1(B)$: 对应 $A=B$ 的情况求和。
- $S_3(B)$: 对应 $A=G$ 的情况求和。
- $S_4(B)$: 对应 $D=B$ 的情况求和。
- $S_5(B)$: 对应 $C=D$ 的情况求和。
- $S_{12}(B)$: 对应 $A=B=G$ 的重叠扣除项。

这些 $S_i(B)$ 函数同样可以通过积性函数的性质在线性筛中维护。

## 4. 复杂度分析

- **时间复杂度**：线性筛的时间复杂度为 $O(N)$。对于 $N=10^7$，计算量约为 $10^7$ 次常数操作，完全可以在 3 秒内完成。
- **空间复杂度**：需要几个 $O(N)$ 的数组（`f`, `s1`, `low` 等），总内存占用约为 100MB - 200MB，远小于 1024MiB 的限制。

## 5. 代码实现要点
- 所有的中间乘法和加法都要注意取模 (`998244353`)。
- 使用 `long long` 防止乘法溢出。
- 线性筛中处理 `i % p == 0` 的情况时，若 `low[next] == next` (即纯质数幂 $p^k$)，则重新计算 $f(p^k)$ 和 $g(p^k)$；否则利用积性直接相乘。

该算法在保证正确性的前提下做到了理论最优的时间复杂度。
